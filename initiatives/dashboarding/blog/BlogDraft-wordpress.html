<!-- 
SUSE Observability Dashboarding Blog Post
WordPress HTML Version
Generated: January 2026

NOTES FOR PUBLISHING:
- Replace image placeholders with actual uploaded media URLs
- Verify all links before publishing
- Test code block rendering in preview
-->

<p>It's 2 AM. Your phone buzzes with an alert: latency spike on the checkout service. You're already awake. Muscle memory kicks in.</p>

<p>Tab one: Grafana. You find the dashboard, but the spike is there, staring back at you. No context. Just a line going up.</p>

<p>Tab two: kubectl. You're hunting for the pod. Which namespace was it again?</p>

<p>Tab three: Your log aggregator. You paste in the pod name, adjust the time range. Wait, is this UTC or local time?</p>

<p>Tab four: Back to Grafana. You try to line up the timestamps manually. Was that memory spike at 2:03 or 2:04?</p>

<p>This is the "Alt-Tab tax" on troubleshooting. It's not just the context switching. It's that <em>you</em> become the integration layer. Each tool has its own time range, its own data format, its own view of the world. None of them talk to each other.</p>

<p><strong>The hardest part of debugging isn't finding the data. It's connecting it.</strong></p>

<hr />

<h2>Dashboards Connected to Your Architecture</h2>

<p>SUSE Observability Dashboarding isn't just another charting tool. It's topology-aware so every widget links directly to the components in your architecture. No datasource configuration, no plugin management, no separate login.</p>

<!-- IMAGE PLACEHOLDER: Hero Screenshot
Upload DashboardDemo1.png and replace this comment with:
<figure>
<img src="[UPLOADED_IMAGE_URL]" alt="SUSE Observability Dashboard showing topology links on widgets" />
<figcaption>Each widget links directly to the component in your architecture. Click the chart, see the context.</figcaption>
</figure>
-->

<p><strong>Stop managing dashboards. Start using them.</strong></p>

<p>The difference is in the details. Every widget links back to its data source. That time series showing memory usage? Click on the link, and you're looking at the pod in your topology. Not a query builder, not a search box, but the actual component with its health state and related services.</p>

<hr />

<h2>The Workflow: Build Context, Don't Just View It</h2>

<p>Most dashboards are destinations. You go there to look at data. SUSE Observability dashboards are workflows. You build them as you investigate.</p>

<h3>The Pin-to-Dashboard Workflow</h3>

<p>You're investigating a latency spike on the catalog service. While looking at the component, you notice memory usage correlating with the spike: a jump from 1.2GB to 1.8GB right when HTTP latency hit 340ms. Shift-click to drop a time marker at that moment. The marker appears across every widget, so you can instantly see what else was happening at 02:43. One click to pin the metric. Another click to add it to a dashboard. You keep investigating, pinning more metrics as you go.</p>

<!-- IMAGE PLACEHOLDER: Pin-to-Dashboard Workflow
Upload DashboardDemo3.png (or GIF) and replace this comment with:
<figure>
<img src="[UPLOADED_IMAGE_URL]" alt="Pin to Dashboard workflow in SUSE Observability" />
<figcaption>Pin it. Build it. Fix it.</figcaption>
</figure>
-->

<p>By the time you've found the root cause, you've built a War Room. Not a room full of panicked engineers, but a shared view that captures the entire investigation. Tomorrow's post-mortem practically writes itself. The dashboard becomes a record of what you found, not a static display you hoped had the right charts.</p>

<h3>Time Travel is More Than a Time Range Selector</h3>

<p>This is where SUSE Observability dashboards fundamentally differ from Grafana.</p>

<p>When your VP asks "What happened at 2:47 AM?", you don't scrub timelines hoping to line things up. You freeze the entire system (topology, health states, metrics) at that exact moment. Time Travel isn't just a time range picker. It's state preservation.</p>

<ul>
<li>View your dashboard at any historical point, with the topology state from that moment</li>
<li>Share the exact instant with colleagues: "Look at 2:47 AM when the spike happened"</li>
<li>Everyone sees the same context, the same health states, the same component relationships</li>
</ul>

<p>No Slack thread asking "Are you looking at UTC or local time?" No manual correlation. The system preserves what your infrastructure looked like at any point in history.</p>

<hr />

<h2>One Platform, No Assembly Required</h2>

<p>Grafana is excellent at visualization. If you need 50 widget types or highly specialized visualizations, it's still the right tool for that job.</p>

<p>But for troubleshooting and cross-component visibility? You no longer need a separate tool.</p>

<table>
<thead>
<tr>
<th>Aspect</th>
<th>Typical Approach (Grafana)</th>
<th>SUSE Observability</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Setup</strong></td>
<td>Configure datasources, manage plugins</td>
<td>Built-in, just works</td>
</tr>
<tr>
<td><strong>Context</strong></td>
<td>Charts are isolated</td>
<td>Widgets link to topology</td>
</tr>
<tr>
<td><strong>Troubleshooting</strong></td>
<td>Separate workflow</td>
<td>Integrated pin → dashboard</td>
</tr>
<tr>
<td><strong>Time Travel</strong></td>
<td>Manual time range selection</td>
<td>System-wide state preservation</td>
</tr>
<tr>
<td><strong>Maintenance</strong></td>
<td>Another tool to manage</td>
<td>Part of the platform</td>
</tr>
</tbody>
</table>

<p><strong>The real cost of "build it yourself":</strong></p>

<p>The typical DIY stack: Prometheus for metrics, Elasticsearch for logs, Jaeger for traces, and Grafana to tie it together. Each tool has its own data model, its own query language. Grafana can visualize all of them, but it can't correlate them.</p>

<p>SUSE Observability is different. Metrics, logs, traces, and topology live in one platform, correlated by default. When you build a dashboard, you're visualizing data that's already connected to your component relationships.</p>

<p>Five widget types (Time Series, Bar Chart, Stat, Gauge, and Markdown), purpose-built for the job. Full PromQL support with auto-complete. Variables for dynamic filtering. Every widget automatically linked to its source component.</p>

<hr />

<h2>Real-World Use Cases</h2>

<h3>Use Case 1: The Technical Dashboard</h3>

<p>You're the engineer responsible for the payment service. The one that processes every transaction and touches half the microservices in your stack. When payment latency creeps up, customers abandon carts. When it goes down, revenue stops.</p>

<p>You need a single view that answers: "Is payment healthy right now?" Without opening five tabs.</p>

<p>In SUSE Observability, you create a new dashboard and start adding widgets manually. Request rate and response times are straightforward—add a Stat widget, add a Time Series widget, write your PromQL queries. But for CPU usage, you don't want a chart with 47 lines for every pod in the namespace. You want the top offenders.</p>

<p>So you add a Time Series widget and write a query using <code>topk()</code>:</p>

<pre><code>topk(5, sum by(pod_name)(rate(container_cpu_usage{namespace="${namespace}"}[5m])))</code></pre>

<p>This gives you the top 5 pods by CPU usage—the ones actually worth watching. The chart stays readable, and when one of those pods starts climbing, you'll see it immediately.</p>

<p>Your finished dashboard:</p>
<ul>
<li><strong>Stat:</strong> 847 requests/second, current throughput at a glance</li>
<li><strong>Time Series:</strong> Response times over the last hour, with threshold lines at 200ms and 500ms</li>
<li><strong>Time Series:</strong> Top 5 pods by CPU usage (the query above)</li>
<li><strong>Gauge:</strong> Memory at 73% of limit (orange means watch it, red means act)</li>
</ul>

<p>You use a <code>${namespace}</code> variable, so the same dashboard works across dev, staging, and production. Each widget links back to the actual pod in your topology—so when you see a spike, one click takes you to the component, its logs, and its traces. No context switching required.</p>

<h3>Use Case 2: The Business Dashboard</h3>

<p>Your VP keeps asking: "Are checkouts healthy?" They don't care about pods or namespaces. They care about revenue.</p>

<p>So you build them a dashboard, not in a separate BI tool, but right in SUSE Observability where the data already lives. You pull checkout metrics from the order service, payment success rates from the payment gateway, and latency from the inventory check. Because SUSE Observability already understands how these services connect, you're not wiring up datasources or writing complex joins. You're just selecting the metrics that matter to the business.</p>

<p>The result:</p>
<ul>
<li><strong>Stat:</strong> "1,247 successful checkouts in the last hour" (the number they actually care about)</li>
<li><strong>Time Series:</strong> Checkout success rate over time (currently 99.2%)</li>
<li><strong>Gauge:</strong> Payment gateway latency at 89ms, well under the 200ms threshold</li>
<li><strong>Markdown:</strong> Links to technical dashboards for cart, payment, and inventory services</li>
</ul>

<!-- IMAGE PLACEHOLDER: Business Dashboard
Upload DashboardDemo5.png and replace this comment with:
<figure>
<img src="[UPLOADED_IMAGE_URL]" alt="Business KPI dashboard in SUSE Observability" />
<figcaption>Business KPIs with one-click drill-down to technical details.</figcaption>
</figure>
-->

<p>Now when the success rate dips, your VP doesn't ping you on Slack. They click the markdown link to the payment service dashboard, see the technical view, and understand the impact. Same platform, different lens.</p>

<h3>Use Case 3: The Incident War Room</h3>

<p>It's 2:43 AM. Alerts fire on the catalog service. You open SUSE Observability, navigate to the component, and see memory climbing fast.</p>

<p>Here's where the workflow changes everything: instead of copying metrics to a notepad or screenshotting Grafana, you click "Pin to Dashboard" and select "New Dashboard." You name it "Catalog Incident 2026-01-15" and keep investigating.</p>

<p>You check HTTP latency on the same pod—there's a 340ms spike correlating with the memory climb. Pin it. You pull up the error rate. Pin it. Each pin takes one click. Within three minutes, you've built a War Room view:</p>

<ul>
<li><strong>Time Series:</strong> Memory spike on catalog-service-7d4f8b, jumped from 1.2GB to 1.8GB at 02:43</li>
<li><strong>Time Series:</strong> HTTP latency on the same pod, 340ms spike correlating with memory</li>
<li><strong>Stat:</strong> Error rate hit 2.3% during the incident window</li>
<li><strong>Markdown:</strong> "Root cause: OOM pressure from uncached product queries. Fix deployed 02:58."</li>
</ul>

<p>Shift-click on the memory spike to drop a time marker—it appears across every widget, so you can visually confirm the correlation. Share the dashboard URL with your colleague. They see exactly what you see, at exactly the same moment in time.</p>

<p>The dashboard isn't just a view. It's your incident record: shareable, time-travel-enabled, and permanently linked to the components involved. Tomorrow's post-mortem writes itself.</p>

<hr />

<h2>Get Started</h2>

<p><strong>Dashboarding is available now in SUSE Observability.</strong></p>

<p>→ <a href="https://www.suse.com/products/rancher/observability/"><strong>Explore dashboards on the playground</strong></a> to see topology-aware dashboards in action, no setup required</p>

<p>→ <a href="https://docs.stackstate.com/use/dashboards"><strong>Read the documentation</strong></a> to build your first dashboard in 5 minutes</p>

<p>Already a customer? Open SUSE Observability, click "Dashboards," and start building.</p>

<hr />

<p><strong>Your engineers deserve more than scattered views. Give them a home connected to your architecture.</strong></p>
